# Potato Farm
#### Video Demo:  <https://youtu.be/beTvtCAbtQY>
#### Description:
Note: This was the 'README.md' submitted as part of the CS50 Python Final Project, written per the requirements of the project. 
This project (Potato Farm), is a simple command-line game based on chance and decision making. In it, you have a "garden" and each "season", you grow and sell a random number of potatoes - initially between 1 and 10, for $1 each. At the start of the game, you decide upon a goal for yourself (some amount of money to reach from the starting $100/$80/$50 (determined by selected difficulty)), and once you reach that goal, you can quit or continue playing. Growing potatoes degrades the garden quality, in that it uses up the 'nutrients' in the ground, uses up 'pest control' measures and the garden itself will become damaged and needs to be 'maintained'. After each season when you have made some money, you can then spend money on fertiliser, to replenish the nutrients in the garden, pest control measures to keep the pests away, or on repairs to fix the garden. These cost money, but aren't a problem initially. However, if left for too long, each aspect has a chance of ending the game and causing the player to lose. For example, in the games current state, if the pest control drops below 0.10 (out of 1), every season there is a 10% chance that "pests will overrun the garden" and the player will lose. This increases to 20% if they run out of pest control entirely. Additionally, the potato yield a player can get decreases when one or multiple of their garden quality attributes falls below 0.10, leading to less money. Because of these risks, the player must carefully decide when to spend money to uphold their garden, while also trying to make profits. As mentioned, if the player makes it to their financial goal, they can either quit the game, or continue in freeplay mode in which the game will continue forever, unless/until they lose as per before.

This project only contains one main file (project.py) in which all the function of the game happens. It also has two .txt file that includes quick planning and a requirements.txt file noting that only pip installable module (tabulate), this README file and a test file containing several unit tests covering the notable functions in the program outside of main, which also test the two classes used in the program. There is also a directory that contains an older version of the game with it's corresponding REAMDE and test files.

The getdifficulty() function allows the user to select a difficulty for the game, which influences how much the garden quality attributes decrease per season and their starting money. The start() function is used to set your financial goal. The potato_yield() function generates some amount of potatoes and money that is deposited into the players bank. The dec_quality() function (decrease quality) decreases the value of each attribute for the garden (refered to ingame as a "plot", ie garden plot). The goal() function checks your current money against your goal each season to see if you have reached your goal and if you have, prompts you to either quit or continue in freeplay. Choosing freeplay then prevents the goal function from being called again, even if the player drops below their original target. Finally, the shop() function, displays and allows players to choose one (or none) of the attributes (per season), to replenish, or to upgrade their garden to get a higher yield (upto 3 times, increasing the potential maximum by 5 each time, for a maximum of 25 potatoes per season).

In this current version of the game, the player only has one garden plot, although there is some code that could allow for the player to have multiple plots in a more developed version of the game. Using classes is helpful when it comes to scalability for reasons like this, as it means the code doesn't have to be entirely rewritten if I want to include a change like this in future versions, which is something that I have initially had in mind (however decided not to implement as it may quickly become challenging to manage in the game, given things like the shop system, and instead I decided to focus more on experimenting with different values for some in game variables, and balancing). Classes also help with some other aspects regarding the functionality of the code, for example, allowing you to access varaibles easier in different functions, such as the account's money. Another design implementation I did was a subtle "score" that is only mentioned at the end of the game when the goal is met. This score is based on the time it takes you to beat the game, with the player getting a higher score for taking less time per season to decide what (if any) attribute to replenish in their garden, thus essentially introducing a 'skill' (in terms of 'decision making'/'decision processing' time) aspect to the game, along with the RNG component, which allows for better replayability, as players can try to get higher scores each time they play.

A next step for development of a project like this could be adding more gameplay features, such as crop cycling (not only using potatoes but other crops as well and cycling through, which could introduce other factors that alter gameplay), a system of having multiple crops plots, and maybe more skill aspects, such as memorisation or knowledge (which could interact with other aspects of the game such as the current speed aspect, or crop cycling if that is added too). For this to be a full blown-game and exciting to play, it would probably require a user interface, which developing one is well beyond the skills I have. For now as a simple python CLI game, it presents more of an opportunity for interested people to experiment with balancing and how different parameters and RNG can impact gameplay and difficulty. Experimenting with different values for the game could help interested people learn more about what is reasonable to affect difficulty, e.g. at what point does the game become nearly impossible or impossible to beat, even when playing optimally. Another fun thing could be to develop an algorithm to find the optimal way to play the game, which could vary with different parameters for the game.
